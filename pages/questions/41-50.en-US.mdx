import Question from '../../components/Question.tsx'
import Answer from '../../components/Answer.tsx'

# 41-50

### Q. 41. What's the output?

<Question render={
  <Answer answer="B">
  <Answer.Option>A: false, true, false</Answer.Option>
  <Answer.Option>B: false, false, true</Answer.Option>
  <Answer.Option>C: false, true, true</Answer.Option>
  <Answer.Option>D: true, true, false</Answer.Option>
</Answer>
}>

```javascript
!!null
!!''
!!1
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: B_**

`null` is falsy. `!null` returns `true`. `!true` returns `false`.

`""` is falsy. `!""` returns `true`. `!true` returns `false`.

`1` is truthy. `!1` returns `false`. `!false` returns `true`.

</details>

---

### Q. 42. What does the `setInterval` method return in the browser?

<Question render={
  <Answer answer="A">
  <Answer.Option>A: a unique id</Answer.Option>
  <Answer.Option>B: the amount of milliseconds specified</Answer.Option>
  <Answer.Option>C: the passed function</Answer.Option>
  <Answer.Option>D: `undefined`</Answer.Option>
</Answer>
}>

```javascript
setInterval(() => console.log('Hi'), 1000)
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: A_**

It returns a unique id. This id can be used to clear that interval with the `clearInterval()` function.

</details>

---

### Q. 43. What does this return?

<Question render={
  <Answer answer="A">
  <Answer.Option>A: ["L", "y", "d", "i", "a"]</Answer.Option>
  <Answer.Option>B: ["Lydia"]</Answer.Option>
  <Answer.Option>C: [[], "Lydia"]</Answer.Option>
  <Answer.Option>D: [["L", "y", "d", "i", "a"]]</Answer.Option>
</Answer>
}>

```javascript
const name = 'Lydia'
[...name]
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: A_**

A string is an iterable. The spread operator maps every character of an iterable to one element.

</details>

---

### Q. 44. What's the output?

<Question render={
  <Answer answer="C">
  <Answer.Option>A: [0, 10], [10, 20]</Answer.Option>
  <Answer.Option>B: 20, 20</Answer.Option>
  <Answer.Option>C: 10, 20</Answer.Option>
  <Answer.Option>D: 0, 10 and 10, 20</Answer.Option>
</Answer>
}>

```javascript
function* generator(i) {
  yield i
  yield i * 2
}

const gen = generator(10)

console.log(gen.next().value)
console.log(gen.next().value)
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: C_**

Regular functions cannot be stopped mid-way after invocation. However, a generator function can be "stopped" midway, and later continue from where it stopped. Every time a generator function encounters a `yield` keyword, the function yields the value specified after it. Note that the generator function in that case doesnâ€™t _return_ the value, it _yields_ the value.

First, we initialize the generator function with `i` equal to `10`. We invoke the generator function using the `next()` method. The first time we invoke the generator function, `i` is equal to `10`. It encounters the first `yield` keyword: it yields the value of `i`. The generator is now "paused", and `10` gets logged.

Then, we invoke the function again with the `next()` method. It starts to continue where it stopped previously, still with `i` equal to `10`. Now, it encounters the next `yield` keyword, and yields `i * 2`. `i` is equal to `10`, so it returns `10 * 2`, which is `20`. This results in `10, 20`.

</details>

---

### Q. 45. What does this return?

<Question render={
  <Answer answer="B">
  <Answer.Option>A: "one"</Answer.Option>
  <Answer.Option>B: "two"</Answer.Option>
  <Answer.Option>C: "two" "one"</Answer.Option>
  <Answer.Option>D: "one" "two"</Answer.Option>
</Answer>
}>

```javascript
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, 'one')
})

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, 'two')
})

Promise.race([firstPromise, secondPromise]).then((res) => console.log(res))
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: B_**

When we pass multiple promises to the `Promise.race` method, it resolves/rejects the _first_ promise that resolves/rejects.

To the `setTimeout` method, we pass a timer: 500ms for the first promise (`firstPromise`), and 100ms for the second promise (`secondPromise`).

This means that the `secondPromise` resolves first with the value of `'two'`. `res` now holds the value of `'two'`, which gets logged.

</details>

---

### Q. 46. What's the output?

<Question render={
  <Answer answer="D">
<Answer.Option>A: null</Answer.Option>
  <Answer.Option>{"B: [null]"}</Answer.Option>
  <Answer.Option>{"C: [{}]"}</Answer.Option>
  <Answer.Option>{"D: [{ name: 'Lydia' }]"}</Answer.Option>
</Answer>
}>

```javascript
let person = { name: 'Lydia' }
const members = [person]
person = null

console.log(members)
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: D_**

First, we declare a variable `person` with the value of an object that has a `name` property.

<img src="https://i.imgur.com/TML1MbS.png" width="200" />

Then, we declare a variable called `members`. We set the first element of that array equal to the value of the `person` variable. Objects interact by _reference_ when setting them equal to each other. When you assign a reference from one variable to another, you make a _copy_ of that reference. (note that they don't have the _same_ reference!)

<img src="https://i.imgur.com/FSG5K3F.png" width="300" />

Then, we set the variable `person` equal to `null`.

<img src="https://i.imgur.com/sYjcsMT.png" width="300" />

We are only modifying the value of the `person` variable, and not the first element in the array, since that element has a different (copied) reference to the object. The first element in `members` still holds its reference to the original object. When we log the `members` array, the first element still holds the value of the object, which gets logged.

</details>

---

### Q. 47. What's the output?

<Question render={
  <Answer answer="B">
<Answer.Option>{'A: { name: "Lydia" }, { age: 21 }'}</Answer.Option>
  <Answer.Option>{'B: "name", "age"'}</Answer.Option>
  <Answer.Option>{'C: "Lydia", 21'}</Answer.Option>
  <Answer.Option>{'D: ["name", "Lydia"], ["age", 21]'}</Answer.Option>
</Answer>
}>

```javascript
const person = {
  name: 'Lydia',
  age: 21,
}

for (const item in person) {
  console.log(item)
}
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: B_**

With a `for-in` loop, we can iterate through object keys, in this case `name` and `age`.

Under the hood, object keys are strings (if they're not a Symbol).

On every loop, we set the value of `item` equal to the current key itâ€™s iterating over. First, `item` is equal to `name`, and gets logged.

Then, `item` is equal to `age`, which gets logged.

</details>

---

### Q. 48. What's the output?

<Question render={
  <Answer answer="B">
<Answer.Option>A: "345"</Answer.Option>
  <Answer.Option>B: "75"</Answer.Option>
  <Answer.Option>C: 12</Answer.Option>
  <Answer.Option>D: "12"</Answer.Option>
</Answer>
}>

```javascript
console.log(3 + 4 + '5')
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: B_**

Operator associativity is the order in which the compiler evaluates the expressions, either left-to-right or right-to-left. This only happens if all operators have the _same_ precedence. We only have one type of operator: `+`. For addition, the associativity is left-to-right.

`3 + 4` gets evaluated first. This results in the number `7`.

`7 + '5'` results in `"75"` because of coercion. JavaScript converts the number `7` into a string, see question 15. We can concatenate two strings using the `+`operator. `"7" + "5"` results in `"75"`.

</details>

---

### Q. 49. What's the value of `num`?

<Question render={
  <Answer answer="C">
<Answer.Option>A: 42</Answer.Option>
  <Answer.Option>B: "42"</Answer.Option>
  <Answer.Option>C: 7</Answer.Option>
  <Answer.Option>D: NaN</Answer.Option>
</Answer>
}>

```javascript
const num = parseInt('7*6', 10)
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: C_**

Only the first numbers in the string is returned. Based on the _radix_ (the second argument in order to specify what type of number we want to parse it to: base 10, hexadecimal, octal, binary, etc.), the `parseInt` checks whether the characters in the string are valid. Once it encounters a character that isn't a valid number in the radix, it stops parsing and ignores the following characters.

`*` is not a valid number. It only parses `"7"` into the decimal `7`. `num` now holds the value of `7`.

</details>

---

### Q. 50. What's the output?

<Question render={
  <Answer answer="C">
<Answer.Option>A: []</Answer.Option>
  <Answer.Option>B: [null, null, null]</Answer.Option>
  <Answer.Option>C: [undefined, undefined, undefined]</Answer.Option>
  <Answer.Option>D: [ 3 x empty ]</Answer.Option>
</Answer>
}>

```javascript
;[1, 2, 3].map((num) => {
  if (typeof num === 'number') return
  return num * 2
})
```

</Question>

<details>
    <summary>
    <b>ðŸ’¡ Answer</b>
    </summary>

**_Answer: C_**

When mapping over the array, the value of `num` is equal to the element itâ€™s currently looping over. In this case, the elements are numbers, so the condition of the if statement `typeof num === "number"` returns `true`. The map function creates a new array and inserts the values returned from the function.

However, we donâ€™t return a value. When we donâ€™t return a value from the function, the function returns `undefined`. For every element in the array, the function block gets called, so for each element we return `undefined`.

</details>

---

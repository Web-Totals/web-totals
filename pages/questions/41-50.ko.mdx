import Question from '../../components/Question.tsx'
import Answer from '../../components/Answer.tsx'

# 41-50

### Q. 41. 무엇이 출력 될까요?

<Question render={
  <Answer answer="B">
  <Answer.Option>A: false, true, false</Answer.Option>
  <Answer.Option>B: false, false, true</Answer.Option>
  <Answer.Option>C: false, true, true</Answer.Option>
  <Answer.Option>D: true, true, false</Answer.Option>
</Answer>
}>

```javascript
!!null
!!''
!!1
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: B_**

`null`은 거짓 같은 값이에요. `!null`은 `true`를 반환해요. `!true`는 `false`를 반환해요.

`""` 은 거짓 같은 값이에요. `!""`은 `true`를 반환해요. `!true`는 `false`를 반환해요.

`1`은 참 같은 값이에요. `!1`은 `false`를 반환해요. `!false`는 `true`를 반환해요.

</details>

---

### Q. 42. `setInterval` 메소드는 브라우저에게 무엇을 반환 할까요?

<Question render={
  <Answer answer="A">
  <Answer.Option>A: a unique id</Answer.Option>
  <Answer.Option>B: the amount of milliseconds specified</Answer.Option>
  <Answer.Option>C: the passed function</Answer.Option>
  <Answer.Option>D: `undefined`</Answer.Option>
</Answer>
}>

```javascript
setInterval(() => console.log('Hi'), 1000)
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: A_**

이것은 유니크한 id를 반환해요. 이 id는 `clearInterval()` 함수의 간격을 없애기 위해 사용될 수 있어요.

</details>

---

### Q. 43. 이것은 무엇을 반환할까요?

<Question render={
  <Answer answer="A">
  <Answer.Option>A: ["L", "y", "d", "i", "a"]</Answer.Option>
  <Answer.Option>B: ["Lydia"]</Answer.Option>
  <Answer.Option>C: [[], "Lydia"]</Answer.Option>
  <Answer.Option>D: [["L", "y", "d", "i", "a"]]</Answer.Option>
</Answer>
}>

```javascript
const name = 'Lydia'
[...name]
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: A_**

문자열은 반복 가능한 객체예요. spread 연산자는 반복 가능한 객체의 모든 문자를 하나의 요소로 매핑해요.

</details>

---

### Q. 44. 무엇이 출력 될까요?

<Question render={
  <Answer answer="C">
  <Answer.Option>A: [0, 10], [10, 20]</Answer.Option>
  <Answer.Option>B: 20, 20</Answer.Option>
  <Answer.Option>C: 10, 20</Answer.Option>
  <Answer.Option>D: 0, 10 and 10, 20</Answer.Option>
</Answer>
}>

```javascript
function* generator(i) {
  yield i
  yield i * 2
}

const gen = generator(10)

console.log(gen.next().value)
console.log(gen.next().value)
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: C_**

일반 함수는 호출 한 뒤 중간에 멈출 수 없어요. 하지만, 제너레이터 함수는 중간에 "멈췄다가", 나중에 중단된 부분부터 계속할 수 있어요. 제너레이터 함수는 `yield` 키워드를 만날 때마다, yield 뒤에 명시된 값을 넘겨줘요. 제너레이터 함수에서는 값을 _반환_ 하지 않고, 값을 _넘겨진다_ 는 것을 유의하세요.

우선, 제너레이터 함수에서 `i`를 `10`으로 초기화해요. `next()` 메소드를 사용해 제너레이터 함수를 호출해요. 처음에 제너레이터 함수를 호출하면, `i`은 `10`이에요. 첫 번째 `yield` 키워드를 만났어요: 그것은 `i`의 값을 넘겨줘요. 이제 제너레이터는 "멈추고", `10`을 출력해요.

그 후, `next()` 메소드를 사용해 함수를 다시 호출해요. 이전에 멈춘 부분에서부터 다시 시작하고, `i`는 여전히 `10`이에요. 이제, 다음 `yield` 키워드를 만나 `i * 2`를 넘겨줘요. `i`는 `10`이므로, `10 * 2`, 즉 `20`을 반환해요. 결과는 `10, 20`이에요.

</details>

---

### Q. 45. 이것은 무엇을 반환할까요?

<Question render={
  <Answer answer="B">
  <Answer.Option>A: "one"</Answer.Option>
  <Answer.Option>B: "two"</Answer.Option>
  <Answer.Option>C: "two" "one"</Answer.Option>
  <Answer.Option>D: "one" "two"</Answer.Option>
</Answer>
}>

```javascript
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, 'one')
})

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, 'two')
})

Promise.race([firstPromise, secondPromise]).then((res) => console.log(res))
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: B_**

복수의 프로미스를 `Promise.race` 메소드에 넘겨주면, _최초_ 의 프로미스를 해결/거부해요.

`setTimeout` 메소드에 타이머를 전달해요: 첫 번째 프로미스(`firstPromise`)에는 500ms, 두 번째 프로미스(`secondPromise`)에는 100ms.

이것은 `'two'`의 값을 가진 `secondPromise`를 최초로 해결한다는 것을 의미해요. 이제 `res`는 `'two'`의 값을 갖고 출력돼요.

</details>

---

### Q.46. 무엇이 출력 될까요?

<Question render={
  <Answer answer="D">
<Answer.Option>A: null</Answer.Option>
  <Answer.Option>{"B: [null]"}</Answer.Option>
  <Answer.Option>{"C: [{}]"}</Answer.Option>
  <Answer.Option>{"D: [{ name: 'Lydia' }]"}</Answer.Option>
</Answer>
}>

```javascript
let person = { name: 'Lydia' }
const members = [person]
person = null

console.log(members)
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: D_**

우선, 변수 `person`의 값을 `name` 속성을 가진 객체로 선언해요.

<img src="https://i.imgur.com/TML1MbS.png" width="200" />

그 후, `members`라는 변수를 선언해요. 배열의 첫 번째 요소에 `person` 변수의 값을 대입해요. 서로를 같게 설정하면 *참조*로 상호작용해요. 어떤 변수에서 다른 변수로 참조를 할당하면, 그 참조의 _복사본_ 을 만들어요. (그들은 _같은_ 참조를 가지고 있지 않다는 것을 유의하세요!)

<img src="https://i.imgur.com/FSG5K3F.png" width="300" />

그리고, 변수 `person`을 `null`로 설정해요.

<img src="https://i.imgur.com/sYjcsMT.png" width="300" />

`person` 변수의 값만 변경할 수 있고, 배열의 첫 번째 요소는 객체에 대한 다른 (복사된) 참조를 가지고 있기 때문에 변경할 수 없어요. `members`의 첫 번째 요소는 여전히 원본 객체에 대한 참조를 유지하고 있어요. `members` 배열을 출력할 때, 첫 번째 요소는 여전히 객체의 값을 갖고 있어 로그가 출력돼요.

</details>

---

### Q. 47. 무엇이 출력 될까요?

<Question render={
  <Answer answer="B">
<Answer.Option>{'A: { name: "Lydia" }, { age: 21 }'}</Answer.Option>
  <Answer.Option>{'B: "name", "age"'}</Answer.Option>
  <Answer.Option>{'C: "Lydia", 21'}</Answer.Option>
  <Answer.Option>{'D: ["name", "Lydia"], ["age", 21]'}</Answer.Option>
</Answer>
}>

```javascript
const person = {
  name: 'Lydia',
  age: 21,
}

for (const item in person) {
  console.log(item)
}
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: B_**

`for-in` 루프를 사용하면, 객체의 키를 통해서 반복할 수 있는데, 이 경우에서는 `name` 그리고 `age`에요.

내부적으로, 객체의 키는 문자열이에요 (심볼이 아니라면 말이죠). 모든 루프에서, `item`의 값은 반복 중인 현재의 키 값으로 동일하게 설정해요.

우선, `item`은 `name`으로 출력돼요. 그 후, `item`은 `age`로 출력돼요.

</details>

---

### Q. 48. 무엇이 출력 될까요?

<Question render={
  <Answer answer="B">
<Answer.Option>A: "345"</Answer.Option>
  <Answer.Option>B: "75"</Answer.Option>
  <Answer.Option>C: 12</Answer.Option>
  <Answer.Option>D: "12"</Answer.Option>
</Answer>
}>

```javascript
console.log(3 + 4 + '5')
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: B_**

연산자 결합성은 왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽으로 컴파일러가 표현 식을 평가하는 순서가 돼요. 이것은 연산자가 _같은_ 우선순위를 가진 경우에만 해당돼요. 한 유형의 연산자만 있어요: `+`. 게다가, 결합성은 왼쪽에서 오른쪽이에요.

처음으로 `3 + 4`가 평가돼요. 결과는 숫자 `7`이에요.

`7 + '5'`의 결과는 강제성 때문에 `"75"`가 돼요. JavaScript는 숫자 `7`을 문자열로 변환하고, (관련된 자세한 설명은) 질문 15를 보세요. `+` 연산자를 사용해서 두 개의 문자열을 연결할 수 있어요. `"7" + "5"`의 결과는 `"75"`이에요.

</details>

---

### Q. 49. `num`의 값은 무엇일까요?

<Question render={
  <Answer answer="C">
<Answer.Option>A: 42</Answer.Option>
  <Answer.Option>B: "42"</Answer.Option>
  <Answer.Option>C: 7</Answer.Option>
  <Answer.Option>D: NaN</Answer.Option>
</Answer>
}>

```javascript
const num = parseInt('7*6', 10)
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: C_**

문자열의 첫 번째 숫자만 반환돼요. _진법_ 에 근거해(파싱하고자 하는 숫자의 기준을 명시하기 위한 두 번째 인수: 기본 10진수, 6진수, 8진수, 2진수 등), `parseInt`는 문자열 내의 문자가 타당한지 여부를 확인해요. 진수에 유효한 숫자가 아닌 문자를 만나면, 파싱을 멈추고, 다음 문자를 무시해요.

`*`은 유효한 숫자가 아니에요. `"7"`만 십진수의 `7`로 파싱 돼요. 이제 `num`은 `7`의 값을 가져요.

</details>

---

### Q. 50. 무엇이 출력 될까요?

<Question render={
  <Answer answer="C">
<Answer.Option>A: []</Answer.Option>
  <Answer.Option>B: [null, null, null]</Answer.Option>
  <Answer.Option>C: [undefined, undefined, undefined]</Answer.Option>
  <Answer.Option>D: [ 3 x empty ]</Answer.Option>
</Answer>
}>

```javascript
;[1, 2, 3].map((num) => {
  if (typeof num === 'number') return
  return num * 2
})
```

</Question>

<details>
    <summary>
    <b>💡 답</b>
    </summary>

**_답: C_**

배열을 매핑할 때, `num`의 값은 헌재 순환하고 있는 요소예요. 이 경우 요소는 숫자이기 때문에, if 문의 조건 `typeof num === "number"`는 `true`를 반환해요. map 함수는 새로운 배열을 만들고 함수에서 반환된 값을 삽입해요.

그러나, 우리는 값을 반환하지 않아요. 함수는 값을 반환하지 않을 때 `undefined`를 반환해요. 배열에서의 모든 요소에 대해 함수 블록이 호출되므로, 각 요소에 대해 `undefined`를 반환해요.

</details>

---
